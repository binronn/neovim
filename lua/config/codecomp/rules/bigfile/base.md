# 大文件处理规则

## 核心原则

**禁止完整读取大文件！** 必须使用工具进行定向查找和过滤。

## 文件大小判断

- 超过 500 行的文件视为大文件
- 超过 100KB 的文件视为大文件
- 当不确定文件大小时，先假设它是大文件

## 禁止的操作

- ❌ 不要使用 `read_file` 读取整个大文件
- ❌ 不要请求用户发送完整文件内容
- ❌ 不要假设你已经知道文件的全部内容

## 推荐工具使用流程

### 1. 初步了解文件结构

使用 `find_code` 或类似工具获取文件概览：

```
- 先查找文件中的类定义
- 再查找文件中的函数定义
- 记录感兴趣的符号位置
```

### 2. 定向查找目标代码

根据任务需求，使用搜索工具定位具体代码：

```
- 使用 grep/搜索工具查找特定函数名
- 使用 grep/搜索工具查找特定类名
- 使用 grep/搜索工具查找特定变量或关键字
```

### 3. 按需读取代码片段

只读取必要的代码块：

```
- 读取特定函数的实现（通过行号范围）
- 读取特定类的方法
- 读取相关的配置或常量定义
```

### 4. 迭代深入

如果需要理解代码的调用关系：

```
- 找到函数调用处，读取调用上下文
- 找到依赖的定义处，按需读取
- 逐步构建对代码的理解，而非一次性加载
```

## 工具使用示例

### 示例场景：修改大文件中的某个函数

**错误做法：**
```
❌ 读取整个文件查看内容
```

**正确做法：**
```
1. 使用搜索工具查找目标函数名，获取行号
2. 读取函数所在的小范围代码块（如行号 100-150）
3. 如果需要理解依赖，搜索并读取相关定义
4. 基于获取的信息进行修改
```

## 代码修改策略

### 使用精确匹配编辑

- 使用 `insert_edit_into_file` 工具时，提供足够的上下文确保唯一匹配
- 编辑前确认目标代码位置正确
- 避免基于不完整信息的大规模重构

### 批量修改时的处理

- 将大修改拆分为多个小步骤
- 每个步骤只处理一个逻辑单元（一个函数或一个类）
- 每次修改后验证位置信息的准确性

## 性能考虑

- 减少不必要的文件 I/O 操作
- 缓存已读取的代码片段信息
- 避免重复搜索相同内容

## 特殊情况处理

### 需要全局理解时

如果任务确实需要了解文件的全局结构：

1. 使用工具生成文件大纲（类、函数列表）
2. 基于大纲选择性深入
3. 分多次对话逐步构建完整理解

### 文件格式特殊时

- JSON/YAML/XML 大文件：使用专门的解析工具或路径定位
- 日志文件：使用 tail/head 或时间范围过滤
- 二进制文件：避免直接读取，使用专用工具

## 检查清单

在处理任何文件前，先确认：

- [ ] 文件是否可能很大？
- [ ] 我是否只需要其中一小部分内容？
- [ ] 我是否可以使用搜索工具定位目标？
- [ ] 我是否可以只读取必要的代码片段？

## 违规后果

违反此规则可能导致：

- 上下文窗口溢出，丢失重要信息
- 响应时间过长，用户体验差
- 基于不完整信息做出错误修改
- 不必要的 Token 消耗

**始终记住：精准定位，按需读取，避免全量加载！**

